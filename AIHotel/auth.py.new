import logging
import os
from datetime import datetime, timedelta
from typing import Optional

from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer
from passlib.context import CryptContext
from jose import JWTError, jwt
import asyncpg

# Logging
logger = logging.getLogger(__name__)

# JWT constants
SECRET_KEY: str = ""  # Will be loaded at runtime
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 1440  # 24 hours


def get_secret_key() -> str:
    """Get JWT secret key from file or environment."""
    global SECRET_KEY
    
    # Try to read from mounted secret file first
    secret_file = "/app/secret_key.txt"
    if os.path.isfile(secret_file):
        with open(secret_file, 'r') as f:
            key = f.read().strip()
            if key:
                SECRET_KEY = key
                return key
    
    # Fall back to environment variable
    key = os.getenv("JWT_SECRET_KEY")
    if key:
        SECRET_KEY = key
        return key
    
    # Final fallback
    SECRET_KEY = "your-secret-key-change-in-production-2026"
    return SECRET_KEY


# Password hashing for new users
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# HTTP Bearer token scheme
security = HTTPBearer()


class AuthService:
    """Authentication service for travelers."""

    def __init__(
        self,
        db_host: str = os.getenv("DB_HOST", "localhost"),
        db_port: int = int(os.getenv("DB_PORT", 5433)),
        db_name: str = os.getenv("DB_NAME", "hotel_db"),
        db_user: str = os.getenv("DB_USER", "hotel_user"),
        db_password: str = os.getenv("DB_PASSWORD", "hotel_pass"),
    ):
        self.db_host = db_host
        self.db_port = db_port
        self.db_name = db_name
        self.db_user = db_user
        self.db_password = db_password
        self.pool = None

    async def connect(self):
        """Connect to database."""
        try:
            self.pool = await asyncpg.create_pool(
                host=self.db_host,
                port=self.db_port,
                database=self.db_name,
                user=self.db_user,
                password=self.db_password,
                min_size=5,
                max_size=20,
            )
            logger.info("Auth service connected to database")
        except Exception as e:
            logger.error(f"Failed to connect to database: {e}")
            raise

    async def disconnect(self):
        """Disconnect from database."""
        if self.pool:
            await self.pool.close()

    async def authenticate_user(
        self, email: str, password: str
    ) -> Optional[dict]:
        """Authenticate user by email and password."""
        if not self.pool:
            return None

        try:
            async with self.pool.acquire() as conn:
                user = await conn.fetchrow(
                    "SELECT id, email, password FROM auth_user WHERE email = $1",
                    email,
                )

            if not user:
                return None

            # Verify password
            if not verify_password(password, user["password"]):
                return None

            return {"id": user["id"], "email": user["email"]}
        except Exception as e:
            logger.error(f"Authentication error: {e}")
            return None

    def create_access_token(
        self, data: dict, expires_delta: Optional[timedelta] = None
    ) -> str:
        """Create JWT access token."""
        to_encode = data.copy()

        if expires_delta:
            expire = datetime.utcnow() + expires_delta
        else:
            expire = datetime.utcnow() + timedelta(
                minutes=ACCESS_TOKEN_EXPIRE_MINUTES
            )

        to_encode.update({"exp": expire})

        # Get the secret key at encode time
        secret = get_secret_key()
        
        encoded_jwt = jwt.encode(to_encode, secret, algorithm=ALGORITHM)
        return encoded_jwt

    def verify_token(self, token: str) -> Optional[dict]:
        """Verify JWT token and return payload."""
        try:
            # Get the secret key at decode time
            secret = get_secret_key()
            
            payload = jwt.decode(token, secret, algorithms=[ALGORITHM])
            return payload
        except JWTError as e:
            logger.error(f"Token verification failed: {e}")
            return None


async def get_current_user(
    token: str = Depends(security),
) -> dict:
    """Dependency to get current user from JWT token."""
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )

    auth_svc = get_auth_service()

    # Verify token
    payload = auth_svc.verify_token(token.credentials)

    if payload is None:
        raise credentials_exception

    # Support both 'user_id' (Django) and 'sub' (standard JWT) fields
    user_id = payload.get("user_id") or payload.get("sub")

    if user_id is None:
        raise credentials_exception

    return {"user_id": user_id, "email": payload.get("email")}


_auth_service: Optional[AuthService] = None


def get_auth_service() -> AuthService:
    """Get or create auth service singleton."""
    global _auth_service
    if _auth_service is None:
        _auth_service = AuthService()
    return _auth_service


def hash_password(password: str) -> str:
    """Hash password using bcrypt."""
    return pwd_context.hash(password)


def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verify password against hash."""
    return pwd_context.verify(plain_password, hashed_password)
